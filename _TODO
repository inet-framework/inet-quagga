CONVERSION TO OMNET++40:
- "like" --> interface, "extends"
- configurator: moduleTypes, nonIPModuleTypes: use marker properties (@device(true)?) instead
- move "q=queue" too into the default display string
- trim ini files 
- channels: make them inner types
- add gate @labels
- introduce duplex gates
- gross renaming of gates and parameters, to make them more consistent


--------
- add IdealRadio, DistanceBasedRadio, GilbertElliotRadio.
   in DistanceBasedRadio: decouple transmission range from interference range 
   (ie use 2 different module parameters)
--------
- model link failures, via isDown() method of InterfaceEntry. L2 modules 
  should understand isDown(), and FailureManager should be enhanced with
  linkdown/linkup commands. See email on list archive on 9/17/2006 10:34 AM
--------
- create NetworkInterfaces/Base subdirectory: AirFrame, WirelessMacBase,
  ChannelAccess, etc.
--------
- Ieee80211Mac to fire TxNotifDetails when Ack arrives for a frame. Mgmt layer 
  to use this notification to learn when ProbeRequest or AssociationResponse
  has been transmitted.
--------
- code consistency: use omit-get-verb everywhere, including the Ieee80211 models?
--------
- ChannelControl: grid; instead of having pMax parameter, it should ask all
  radios and collect pMax from them! (or, directly the range!)
--------
- radio models: when calculating the probability of bit errors, snirMIN is 
  assumed for the whole duration of the frame! This means that if snir 
  changes along the packet duration, we overestimate the probability of 
  bit error. (there should be proper integration there)
--------
- IReceptionModel: 
  - improve it to be able to accomodate antenna gain: calculation function
    should take node positions, antenna directions (maybe this should be in
    some IDirectionalReceptionmodel, plugging into some AbstractDirectionalRadio?)
  - allow for implementing "good/bad channel"-type radio models (Gilbert-Elliot)
    e.g. containsBadChannelState(starttime, endtime)
  - allow the radio model to add extra noise over time, or modify received power
    over time, e.g. using functions like 
      PowerList calculateReceivedPower(...)
      PowerList ambientNoise(...)
    (maybe this should be some IDetailedReceptionModel, plugging into
    a specialized version of AbstractRadio?)
--------
- AbstractRadio: consider: don't sent up the packet if there're bit errors,
  just fire some specific radio state change notification! would simplify the
  Ieee80211Mac state machine a lot! 
--------
- tummiepiggy's TCP bug ("TCP_S_FIN_WAIT_1 timeout" on mailing list)
--------
- quagga/socketmsg: use base/bytearraymessage instead
--------
- implement ICMP rate limiting, see e.g bsd.mod/netinet/ip_icmp.c, badport_bandlim()
- ICMP options: stopOnError (bool param), UDPBadPortSendICMP (bool param)
--------
- problem with NetworkConfigurator + RSVP's FailureManager: after deleting/recreating
  LSR, configured IP addresses and host routes to PPP peers get lost.
  Solution: implement failure/recovery with NF_FAILURE and NF_RECOVERY notifications!
--------
- check in Quagga documentation
- rename Daemon to QuaggaDaemon
--------
- IPvXAddress: change get4()/get6() to v4()/v6()
- Wrap RoutingEntry members into getter/setter methods!
--------
- "ack" in LinkStateMsg redundant? (never read)
Q: what is the TELinkInfo.state flag?
Q: what is UnResvBandwidth[8] indexed with? what is [4] and [7] that gets printed?

--------
- MPLS examples: there's heaps of ICMP errors coming from UDP ("port unreachable")
--------
- BUG: UDP ephemeral port setting: if chosen & stored in UDP, sending further dgrams need to look it up from the SockDesc...
--------
- put NAMTraceWriter into all routers

- dynamic registration of notification categories:
    x.h:  extern const int NF_TED_CHANGED;
    x.cc: const int NF_TED_CHANGED = NotificationBoard::registerCategory("NF_TED_CHANGED");

- "make dist"?

- TCP, UDP: rename gates (after omnetpp-4.0!)

- reading routing files: it doesn't make sense to be able to manually set MULTICAST on an interface

- create example network with both Ethernet and PPP

- IP/IPv6: implement tunnelling

- revise fragmentation in IP

- added userId to TCPCommand -- rewrite TCPSocketMap to make use of userId
        - socket must be inserted into map before bind(), so that a userId can be assigned
        - what about incoming connections? how to assign userId to them?
           IF IT CANNOT BE DONE: remove userId from TCP!!!!

- TCP/UDP: unspec port should be 0 not -1!!!

- NAM trace: doesn't record drops, because DropTailQueue doesn't send notifications

- there's no IPAddress::getPrefix() and getSuffix() (like IPv6Address has)

- apps: add startTime param; IPAddressResolver should only be invoked at startTime not in initialize()!

- TCP tests fail now (TCPDump has changed)

- if a node pings itself, that'll be "destination unreachable" -- fix it

- Eth: restore original conn color when transmission ends

- "headerLength" param in snrEval???

- IPv4 configurator: should fill in next hop addresses too, not only interface (esp with Ethernet)

- rename TCPBasicClientApp to TCPRequestReplyClientApp ?

- IPv4: make it usable with ad-hoc models

- notifboard: switch to the context of the client before calling its receiveNotification()

- implement class PacketQueue : public cQueue

- add more notifications (NotificationBoard): interface up/down, routing table change, etc
- todo for omnetpp-3.2:
     - add handleParameterChange() to apps (needed for Scenario Manager!)
     - makemakefiles: -P option
     - use new opp_msgc features? (kind=..., length=...etc)

----------------------
 - ExtInterface performance optimization: I am not sure how long the pointer from
   pcap_next() is valid [until the next such call perhaps?], but it might be possible
   to spare the allocation of the ExtFrame and the cost of copying the bytes into it
   inside cSocketRTScheduler::receiveWithTimeout(). I mean, the notification message
   could just directly contain the ptr from pcap_next(), plus caplen; so the ExtInterface
   module could directly deserialize from the pcap buffer (and also spare copying the
   bytes out of ExtFrame). There is no concurrency problem, because events are processed
   in strict timestamp order, the notification message has the same timestamp as the
   external event, and receiveWithTimeout() is only invoked again when time has passed
   that timestamp (``if (timeval_greater(targetTime, curTime))'' line in getNextEvent()).
   This could improve the packet rate the simulation can handle in real time.

----------------------
- MPLS models: "gateway" field of routing entries gets lost after TED::rebuildRoutingTable
----------------------
- ICMP: shouldn't we unify ICMP and ICMPv6...? at least types and codes?
  ICMPv6 uses different type&code numeric values but this is only of interest
  if we want to do emulation

- instead of sending up ICMP packet to UDP & TCP: create an ICMPErrorInfo, and
  IP (IPv6) would attach that to the bogus datagram, with message kind IP_I_ICMP_ERROR.
  (win: IP/ICMP dependencies can then be removed from TCP and UDP in makemakefiles!!!)

- ErrorHandling is not used anymore! do we need to send a copy of ICMP errors to the
  ICMP module itself as well?

- TCP: how to handle ICMP error reports?

-----------------------
Interfaces:
- IPv6RoutingTable: change _interfaceId to _ie!!!

- interfaceAt -> interfaceById!!!

- store interfaces in an std::map<int,InterfaceEntry*> inside interfaceTable!
  - this makes it possible to implement interface deletion as well, with preserving ids;
  - or just use a vector like for gates and modules? (apps must check for holes then!)
- notify when an interface gets deleted -- the RoutingTable, ARP etc should remove associated entries

-----------------------
- MPLS/LDP/RSVP:
    - document! ScenarioManager commands, XML file formats, unimplemented features
    - Quagga ospfd: could it serve as OSPF_TE??
- mpls models use interface NAME - why?

-----------------------
- OSPFv2 TODO:
     - should use the proper IPAddress class, not its own one...
     - OSPFTimer class only contains a timerKind() -- is this class necessary at all...?
     - rename ifIndex (SetIfIndex, GetIfIndex, etc) to interfaceId AND change default value to -1!
     - OSPFRouting::LoadInterfaceParameters: interfaceType is contained in InterfaceEntry, it's redundant to read it from XML!
     - try to reduce size of configuration. If Zebra can do it...
-----------------------
into the ipv6 doc:
"
Currently, IPv6 support consists of several modules. The IPv6 module
implements IPv6 datagram handling (sending, forwarding etc). It relies on
RoutingTable6 to get access to the routes. RoutingTable6 also contains the
neighbour discovery data structures (dest cache, neighbour cache, prefix
list -- the latter effectively merged into the route table). Interface
configuration (address, state, timeouts etc) is held in the InterfaceTable,
in IPv6InterfaceData objects attached to InterfaceEntry as its ipv6()
member.

The module IPv6NeighbourDiscovery implements all tasks associated with
neighbour discovery and stateless address autoconfiguration. Its data
structures are in RoutingTable6 (dest cache, neighbour cache, prefix list).
Neighbour discovery packets are only sent and processed by this module --
when IPv6 receives one, it forwards the packet to IPv6NeighbourDiscovery.

The rest of ICMPv6 (ICMP errors, echo request/reply etc) is implemented in
the module ICMPv6, just like with IPv4. ICMP errors are sent into
IPv6ErrorHandling, which the user can extend or replace to get errors
handled in any way they like.
"

-----------------------
TCP:
Slow Start should be applied every time TCP starts to send "after a
sufficiently long idle period".

"Idle" could be interpreted as when the send queue is empty (there's nothing
to send), and there's no unacknowledged data (i.e. previously sent segments
have all been acknowledged). But what is "sufficiently long"? I guess that
should be measured in RTT rather than absolute time (secs). So maybe we
should say 5*RTT is "sufficiently long"?
-----------------------
802.11 bugs: see mailing list...
-----------------------
FlatNetworkConfigurator: assigns the same address to all interfaces of a router.
This is not the usual way things are done on the internet. But if we assign
different addresses, which addr to use in the routing tables etc?
-----------------------
VOJTA:
 -make connect work without bind (autoassign local address based on
destination, currently unspecified address is sent and SYN+ACK will not
be sent back (at least for 127.0.0.1, I didn't check for others))
-----------------------
from http://www.freesoft.org/CIE/Course/Section3/10.htm:

# Per-interface assignment. IP addresses are assigned on a per-interface basis,
so a host might possess several IP addresses if it has several interfaces.
For example, a host with both Ethernet and serial interfaces would have an
IP address for each. This is an important consequence of prefix-based
addressing. An IP address doesn't really refer to a host, it refers to an
interface.

If a host is known by multiple addresses, then every service on this host
can be referred to by multiple names! Addressing this host requires picking
one of these. Since the packet is addressed to the interface and not the host,
path information is introduced into the address. The exact ramifications of
this effect depend heavily on the network design. In particular, careless
design can result in a host becoming reachable by one address but not by
another. The simplest solution to this problem is to select the host's most
reliable interface and advertise its IP address as the host's primary IP
address.

==> current FlatNetworkConfigurator is shit? how to do address assignment?

see also:
 "The Network Administrators' Guide" http://www.tldp.org/LDP/nag/node1.html
 "IP 101: All About IP Addresses" http://www.networkcomputing.com/netdesign/ip101c.html
  - according to this: network numbers and interface addresses don't necessarily
    have to do anything with each other! may look COMPLETELY different

from http://www.networkcomputing.com/netdesign/ip101.html:

The important thing to realize is that while a routing table keeps track of
network numbers, no one assigns a network number to any piece of equipment.
Every interface of a router or host connected on the network must have an IP
address and a subnet mask defined (many pieces of equipment will assign a
default subnet mask if none is applied). From this IP address and subnet mask,
the network number is derived by the IP stack and tracked in the routing table.

Q: if routing tables contain network numbers, are IP addresses of router
interfaces also addressable?
